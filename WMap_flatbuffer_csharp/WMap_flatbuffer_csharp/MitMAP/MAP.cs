// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace MitMAP
{

using global::System;
using global::FlatBuffers;

public struct MAP : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static MAP GetRootAsMAP(ByteBuffer _bb) { return GetRootAsMAP(_bb, new MAP()); }
  public static MAP GetRootAsMAP(ByteBuffer _bb, MAP obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
  public MAP __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public short MaxRow { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetShort(o + __p.bb_pos) : (short)0; } }
  public short MaxCol { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetShort(o + __p.bb_pos) : (short)0; } }
  public short Map(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetShort(__p.__vector(o) + j * 2) : (short)0; }
  public int MapLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMapBytes() { return __p.__vector_as_span(8); }
#else
  public ArraySegment<byte>? GetMapBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public short[] GetMapArray() { return __p.__vector_as_array<short>(8); }
  public stXY? TargetDie(int j) { int o = __p.__offset(10); return o != 0 ? (stXY?)(new stXY()).__assign(__p.__vector(o) + j * 4, __p.bb) : null; }
  public int TargetDieLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
  public stXY? RefDie(int j) { int o = __p.__offset(12); return o != 0 ? (stXY?)(new stXY()).__assign(__p.__vector(o) + j * 4, __p.bb) : null; }
  public int RefDieLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
  public short RefChipDir { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetShort(o + __p.bb_pos) : (short)0; } }
  public short RefNotch { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetShort(o + __p.bb_pos) : (short)0; } }
  public short DegRotated { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetShort(o + __p.bb_pos) : (short)0; } }
  public float DieSizeX { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float DieSizeY { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float DieGapX { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float DieGapY { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float EdgeClearance { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)5.0f; } }
  public float Diameter { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)200.0f; } }
  public string WaferNum { get { int o = __p.__offset(32); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetWaferNumBytes() { return __p.__vector_as_span(32); }
#else
  public ArraySegment<byte>? GetWaferNumBytes() { return __p.__vector_as_arraysegment(32); }
#endif
  public byte[] GetWaferNumArray() { return __p.__vector_as_array<byte>(32); }
  public string WaferFab { get { int o = __p.__offset(34); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetWaferFabBytes() { return __p.__vector_as_span(34); }
#else
  public ArraySegment<byte>? GetWaferFabBytes() { return __p.__vector_as_arraysegment(34); }
#endif
  public byte[] GetWaferFabArray() { return __p.__vector_as_array<byte>(34); }
  public string FabCode { get { int o = __p.__offset(36); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetFabCodeBytes() { return __p.__vector_as_span(36); }
#else
  public ArraySegment<byte>? GetFabCodeBytes() { return __p.__vector_as_arraysegment(36); }
#endif
  public byte[] GetFabCodeArray() { return __p.__vector_as_array<byte>(36); }
  public string IntCode { get { int o = __p.__offset(38); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIntCodeBytes() { return __p.__vector_as_span(38); }
#else
  public ArraySegment<byte>? GetIntCodeBytes() { return __p.__vector_as_arraysegment(38); }
#endif
  public byte[] GetIntCodeArray() { return __p.__vector_as_array<byte>(38); }
  public string LotNum { get { int o = __p.__offset(40); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLotNumBytes() { return __p.__vector_as_span(40); }
#else
  public ArraySegment<byte>? GetLotNumBytes() { return __p.__vector_as_arraysegment(40); }
#endif
  public byte[] GetLotNumArray() { return __p.__vector_as_array<byte>(40); }
  public string Device { get { int o = __p.__offset(42); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDeviceBytes() { return __p.__vector_as_span(42); }
#else
  public ArraySegment<byte>? GetDeviceBytes() { return __p.__vector_as_arraysegment(42); }
#endif
  public byte[] GetDeviceArray() { return __p.__vector_as_array<byte>(42); }
  public string DesignId { get { int o = __p.__offset(44); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDesignIdBytes() { return __p.__vector_as_span(44); }
#else
  public ArraySegment<byte>? GetDesignIdBytes() { return __p.__vector_as_arraysegment(44); }
#endif
  public byte[] GetDesignIdArray() { return __p.__vector_as_array<byte>(44); }
  public string Layout { get { int o = __p.__offset(46); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLayoutBytes() { return __p.__vector_as_span(46); }
#else
  public ArraySegment<byte>? GetLayoutBytes() { return __p.__vector_as_arraysegment(46); }
#endif
  public byte[] GetLayoutArray() { return __p.__vector_as_array<byte>(46); }
  public string ScribId { get { int o = __p.__offset(48); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetScribIdBytes() { return __p.__vector_as_span(48); }
#else
  public ArraySegment<byte>? GetScribIdBytes() { return __p.__vector_as_arraysegment(48); }
#endif
  public byte[] GetScribIdArray() { return __p.__vector_as_array<byte>(48); }
  public string ScribLot { get { int o = __p.__offset(50); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetScribLotBytes() { return __p.__vector_as_span(50); }
#else
  public ArraySegment<byte>? GetScribLotBytes() { return __p.__vector_as_arraysegment(50); }
#endif
  public byte[] GetScribLotArray() { return __p.__vector_as_array<byte>(50); }
  public short MapId { get { int o = __p.__offset(52); return o != 0 ? __p.bb.GetShort(o + __p.bb_pos) : (short)0; } }
  public stXY? StartLoc { get { int o = __p.__offset(54); return o != 0 ? (stXY?)(new stXY()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public short NullBin { get { int o = __p.__offset(56); return o != 0 ? __p.bb.GetShort(o + __p.bb_pos) : (short)0; } }
  public format BincodeFormat { get { int o = __p.__offset(58); return o != 0 ? (format)__p.bb.GetSbyte(o + __p.bb_pos) : format.Ascii; } }

  public static void StartMAP(FlatBufferBuilder builder) { builder.StartObject(28); }
  public static void AddMaxRow(FlatBufferBuilder builder, short maxRow) { builder.AddShort(0, maxRow, 0); }
  public static void AddMaxCol(FlatBufferBuilder builder, short maxCol) { builder.AddShort(1, maxCol, 0); }
  public static void AddMap(FlatBufferBuilder builder, VectorOffset mapOffset) { builder.AddOffset(2, mapOffset.Value, 0); }
  public static VectorOffset CreateMapVector(FlatBufferBuilder builder, short[] data) { builder.StartVector(2, data.Length, 2); for (int i = data.Length - 1; i >= 0; i--) builder.AddShort(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateMapVectorBlock(FlatBufferBuilder builder, short[] data) { builder.StartVector(2, data.Length, 2); builder.Add(data); return builder.EndVector(); }
  public static void StartMapVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(2, numElems, 2); }
  public static void AddTargetDie(FlatBufferBuilder builder, VectorOffset targetDieOffset) { builder.AddOffset(3, targetDieOffset.Value, 0); }
  public static void StartTargetDieVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 2); }
  public static void AddRefDie(FlatBufferBuilder builder, VectorOffset refDieOffset) { builder.AddOffset(4, refDieOffset.Value, 0); }
  public static void StartRefDieVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 2); }
  public static void AddRefChipDir(FlatBufferBuilder builder, short refChipDir) { builder.AddShort(5, refChipDir, 0); }
  public static void AddRefNotch(FlatBufferBuilder builder, short refNotch) { builder.AddShort(6, refNotch, 0); }
  public static void AddDegRotated(FlatBufferBuilder builder, short degRotated) { builder.AddShort(7, degRotated, 0); }
  public static void AddDieSizeX(FlatBufferBuilder builder, float dieSizeX) { builder.AddFloat(8, dieSizeX, 0.0f); }
  public static void AddDieSizeY(FlatBufferBuilder builder, float dieSizeY) { builder.AddFloat(9, dieSizeY, 0.0f); }
  public static void AddDieGapX(FlatBufferBuilder builder, float dieGapX) { builder.AddFloat(10, dieGapX, 0.0f); }
  public static void AddDieGapY(FlatBufferBuilder builder, float dieGapY) { builder.AddFloat(11, dieGapY, 0.0f); }
  public static void AddEdgeClearance(FlatBufferBuilder builder, float edgeClearance) { builder.AddFloat(12, edgeClearance, 5.0f); }
  public static void AddDiameter(FlatBufferBuilder builder, float diameter) { builder.AddFloat(13, diameter, 200.0f); }
  public static void AddWaferNum(FlatBufferBuilder builder, StringOffset waferNumOffset) { builder.AddOffset(14, waferNumOffset.Value, 0); }
  public static void AddWaferFab(FlatBufferBuilder builder, StringOffset waferFabOffset) { builder.AddOffset(15, waferFabOffset.Value, 0); }
  public static void AddFabCode(FlatBufferBuilder builder, StringOffset fabCodeOffset) { builder.AddOffset(16, fabCodeOffset.Value, 0); }
  public static void AddIntCode(FlatBufferBuilder builder, StringOffset intCodeOffset) { builder.AddOffset(17, intCodeOffset.Value, 0); }
  public static void AddLotNum(FlatBufferBuilder builder, StringOffset lotNumOffset) { builder.AddOffset(18, lotNumOffset.Value, 0); }
  public static void AddDevice(FlatBufferBuilder builder, StringOffset deviceOffset) { builder.AddOffset(19, deviceOffset.Value, 0); }
  public static void AddDesignId(FlatBufferBuilder builder, StringOffset designIdOffset) { builder.AddOffset(20, designIdOffset.Value, 0); }
  public static void AddLayout(FlatBufferBuilder builder, StringOffset layoutOffset) { builder.AddOffset(21, layoutOffset.Value, 0); }
  public static void AddScribId(FlatBufferBuilder builder, StringOffset scribIdOffset) { builder.AddOffset(22, scribIdOffset.Value, 0); }
  public static void AddScribLot(FlatBufferBuilder builder, StringOffset scribLotOffset) { builder.AddOffset(23, scribLotOffset.Value, 0); }
  public static void AddMapId(FlatBufferBuilder builder, short mapId) { builder.AddShort(24, mapId, 0); }
  public static void AddStartLoc(FlatBufferBuilder builder, Offset<stXY> startLocOffset) { builder.AddStruct(25, startLocOffset.Value, 0); }
  public static void AddNullBin(FlatBufferBuilder builder, short nullBin) { builder.AddShort(26, nullBin, 0); }
  public static void AddBincodeFormat(FlatBufferBuilder builder, format bincodeFormat) { builder.AddSbyte(27, (sbyte)bincodeFormat, 1); }
  public static Offset<MAP> EndMAP(FlatBufferBuilder builder) {
    int o = builder.EndObject();
    return new Offset<MAP>(o);
  }
  public static void FinishMAPBuffer(FlatBufferBuilder builder, Offset<MAP> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedMAPBuffer(FlatBufferBuilder builder, Offset<MAP> offset) { builder.FinishSizePrefixed(offset.Value); }
};


}
