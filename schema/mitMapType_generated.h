// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MITMAPTYPE_MITMAPTYPE_H_
#define FLATBUFFERS_GENERATED_MITMAPTYPE_MITMAPTYPE_H_

#include "flatbuffers/flatbuffers.h"

namespace MitMapType {

struct stXY;

struct stfXY;

struct stfOFFSET;

struct stRejCode;

struct stUnitInfo;

struct stUnitInfo2;

struct TblUnitInfo2;

struct TblLotInfo;

struct TblWaferInfo;

struct MapRoot;

enum MapType {
  MapType_MAP_GENERIC = 0,
  MapType_MAP_ULT_C330 = 1,
  MapType_MAP_ULT_MR3 = 2,
  MapType_MAP_ULT_MR3_TBL_FMT = 3,
  MapType_MIN = MapType_MAP_GENERIC,
  MapType_MAX = MapType_MAP_ULT_MR3_TBL_FMT
};

inline const MapType (&EnumValuesMapType())[4] {
  static const MapType values[] = {
    MapType_MAP_GENERIC,
    MapType_MAP_ULT_C330,
    MapType_MAP_ULT_MR3,
    MapType_MAP_ULT_MR3_TBL_FMT
  };
  return values;
}

inline const char * const *EnumNamesMapType() {
  static const char * const names[] = {
    "MAP_GENERIC",
    "MAP_ULT_C330",
    "MAP_ULT_MR3",
    "MAP_ULT_MR3_TBL_FMT",
    nullptr
  };
  return names;
}

inline const char *EnumNameMapType(MapType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMapType()[index];
}

enum format {
  format_Ascii = 1,
  format_Hex = 2,
  format_Dec = 3,
  format_MIN = format_Ascii,
  format_MAX = format_Dec
};

inline const format (&EnumValuesformat())[3] {
  static const format values[] = {
    format_Ascii,
    format_Hex,
    format_Dec
  };
  return values;
}

inline const char * const *EnumNamesformat() {
  static const char * const names[] = {
    "Ascii",
    "Hex",
    "Dec",
    nullptr
  };
  return names;
}

inline const char *EnumNameformat(format e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(format_Ascii);
  return EnumNamesformat()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) stXY FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t x_;
  int16_t y_;

 public:
  stXY() {
    memset(this, 0, sizeof(stXY));
  }
  stXY(int16_t _x, int16_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int16_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int16_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(stXY, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) stfXY FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  stfXY() {
    memset(this, 0, sizeof(stfXY));
  }
  stfXY(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(stfXY, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) stfOFFSET FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float a_;

 public:
  stfOFFSET() {
    memset(this, 0, sizeof(stfOFFSET));
  }
  stfOFFSET(float _x, float _y, float _a)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(stfOFFSET, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) stRejCode FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t pc_;
  uint8_t app_;
  uint8_t code_;

 public:
  stRejCode() {
    memset(this, 0, sizeof(stRejCode));
  }
  stRejCode(uint8_t _pc, uint8_t _app, uint8_t _code)
      : pc_(flatbuffers::EndianScalar(_pc)),
        app_(flatbuffers::EndianScalar(_app)),
        code_(flatbuffers::EndianScalar(_code)) {
  }
  uint8_t pc() const {
    return flatbuffers::EndianScalar(pc_);
  }
  uint8_t app() const {
    return flatbuffers::EndianScalar(app_);
  }
  uint8_t code() const {
    return flatbuffers::EndianScalar(code_);
  }
};
FLATBUFFERS_STRUCT_END(stRejCode, 3);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) stUnitInfo FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t pocket_;
  int16_t reel_;
  int16_t bincode_;
  stRejCode rejcode_;
  uint8_t valid_;

 public:
  stUnitInfo() {
    memset(this, 0, sizeof(stUnitInfo));
  }
  stUnitInfo(int32_t _pocket, int16_t _reel, int16_t _bincode, const stRejCode &_rejcode, bool _valid)
      : pocket_(flatbuffers::EndianScalar(_pocket)),
        reel_(flatbuffers::EndianScalar(_reel)),
        bincode_(flatbuffers::EndianScalar(_bincode)),
        rejcode_(_rejcode),
        valid_(flatbuffers::EndianScalar(static_cast<uint8_t>(_valid))) {
  }
  int32_t pocket() const {
    return flatbuffers::EndianScalar(pocket_);
  }
  int16_t reel() const {
    return flatbuffers::EndianScalar(reel_);
  }
  int16_t bincode() const {
    return flatbuffers::EndianScalar(bincode_);
  }
  const stRejCode &rejcode() const {
    return rejcode_;
  }
  bool valid() const {
    return flatbuffers::EndianScalar(valid_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(stUnitInfo, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) stUnitInfo2 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t goodDie_;
  int32_t placedDie_;
  int16_t bincode_;
  stRejCode rejcode_;
  uint8_t valid_;
  uint8_t pnp_;
  int8_t padding0__;
  int16_t pickForce_;
  int16_t placeForce_;
  int16_t purgeForce_;
  stXY inwaferCoor_;
  stXY outwaferCoor_;
  int16_t padding1__;

 public:
  stUnitInfo2() {
    memset(this, 0, sizeof(stUnitInfo2));
  }
  stUnitInfo2(int32_t _goodDie, int32_t _placedDie, int16_t _bincode, const stRejCode &_rejcode, bool _valid, uint8_t _pnp, int16_t _pickForce, int16_t _placeForce, int16_t _purgeForce, const stXY &_inwaferCoor, const stXY &_outwaferCoor)
      : goodDie_(flatbuffers::EndianScalar(_goodDie)),
        placedDie_(flatbuffers::EndianScalar(_placedDie)),
        bincode_(flatbuffers::EndianScalar(_bincode)),
        rejcode_(_rejcode),
        valid_(flatbuffers::EndianScalar(static_cast<uint8_t>(_valid))),
        pnp_(flatbuffers::EndianScalar(_pnp)),
        padding0__(0),
        pickForce_(flatbuffers::EndianScalar(_pickForce)),
        placeForce_(flatbuffers::EndianScalar(_placeForce)),
        purgeForce_(flatbuffers::EndianScalar(_purgeForce)),
        inwaferCoor_(_inwaferCoor),
        outwaferCoor_(_outwaferCoor),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  int32_t goodDie() const {
    return flatbuffers::EndianScalar(goodDie_);
  }
  int32_t placedDie() const {
    return flatbuffers::EndianScalar(placedDie_);
  }
  int16_t bincode() const {
    return flatbuffers::EndianScalar(bincode_);
  }
  const stRejCode &rejcode() const {
    return rejcode_;
  }
  bool valid() const {
    return flatbuffers::EndianScalar(valid_) != 0;
  }
  uint8_t pnp() const {
    return flatbuffers::EndianScalar(pnp_);
  }
  int16_t pickForce() const {
    return flatbuffers::EndianScalar(pickForce_);
  }
  int16_t placeForce() const {
    return flatbuffers::EndianScalar(placeForce_);
  }
  int16_t purgeForce() const {
    return flatbuffers::EndianScalar(purgeForce_);
  }
  const stXY &inwaferCoor() const {
    return inwaferCoor_;
  }
  const stXY &outwaferCoor() const {
    return outwaferCoor_;
  }
};
FLATBUFFERS_STRUCT_END(stUnitInfo2, 32);

struct TblUnitInfo2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GOODDIE = 4,
    VT_PLACEDDIE = 6,
    VT_BINCODE = 8,
    VT_REJCODE = 10,
    VT_VALID = 12,
    VT_PNP = 14,
    VT_PICKFORCE = 16,
    VT_PLACEFORCE = 18,
    VT_PURGEFORCE = 20,
    VT_INWAFERCOOR = 22,
    VT_OUTWAFERCOOR = 24
  };
  int32_t goodDie() const {
    return GetField<int32_t>(VT_GOODDIE, 0);
  }
  int32_t placedDie() const {
    return GetField<int32_t>(VT_PLACEDDIE, 0);
  }
  int16_t bincode() const {
    return GetField<int16_t>(VT_BINCODE, 0);
  }
  const stRejCode *rejcode() const {
    return GetStruct<const stRejCode *>(VT_REJCODE);
  }
  bool valid() const {
    return GetField<uint8_t>(VT_VALID, 0) != 0;
  }
  uint8_t pnp() const {
    return GetField<uint8_t>(VT_PNP, 0);
  }
  int16_t pickForce() const {
    return GetField<int16_t>(VT_PICKFORCE, 0);
  }
  int16_t placeForce() const {
    return GetField<int16_t>(VT_PLACEFORCE, 0);
  }
  int16_t purgeForce() const {
    return GetField<int16_t>(VT_PURGEFORCE, 0);
  }
  const stXY *inwaferCoor() const {
    return GetStruct<const stXY *>(VT_INWAFERCOOR);
  }
  const stXY *outwaferCoor() const {
    return GetStruct<const stXY *>(VT_OUTWAFERCOOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GOODDIE) &&
           VerifyField<int32_t>(verifier, VT_PLACEDDIE) &&
           VerifyField<int16_t>(verifier, VT_BINCODE) &&
           VerifyField<stRejCode>(verifier, VT_REJCODE) &&
           VerifyField<uint8_t>(verifier, VT_VALID) &&
           VerifyField<uint8_t>(verifier, VT_PNP) &&
           VerifyField<int16_t>(verifier, VT_PICKFORCE) &&
           VerifyField<int16_t>(verifier, VT_PLACEFORCE) &&
           VerifyField<int16_t>(verifier, VT_PURGEFORCE) &&
           VerifyField<stXY>(verifier, VT_INWAFERCOOR) &&
           VerifyField<stXY>(verifier, VT_OUTWAFERCOOR) &&
           verifier.EndTable();
  }
};

struct TblUnitInfo2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_goodDie(int32_t goodDie) {
    fbb_.AddElement<int32_t>(TblUnitInfo2::VT_GOODDIE, goodDie, 0);
  }
  void add_placedDie(int32_t placedDie) {
    fbb_.AddElement<int32_t>(TblUnitInfo2::VT_PLACEDDIE, placedDie, 0);
  }
  void add_bincode(int16_t bincode) {
    fbb_.AddElement<int16_t>(TblUnitInfo2::VT_BINCODE, bincode, 0);
  }
  void add_rejcode(const stRejCode *rejcode) {
    fbb_.AddStruct(TblUnitInfo2::VT_REJCODE, rejcode);
  }
  void add_valid(bool valid) {
    fbb_.AddElement<uint8_t>(TblUnitInfo2::VT_VALID, static_cast<uint8_t>(valid), 0);
  }
  void add_pnp(uint8_t pnp) {
    fbb_.AddElement<uint8_t>(TblUnitInfo2::VT_PNP, pnp, 0);
  }
  void add_pickForce(int16_t pickForce) {
    fbb_.AddElement<int16_t>(TblUnitInfo2::VT_PICKFORCE, pickForce, 0);
  }
  void add_placeForce(int16_t placeForce) {
    fbb_.AddElement<int16_t>(TblUnitInfo2::VT_PLACEFORCE, placeForce, 0);
  }
  void add_purgeForce(int16_t purgeForce) {
    fbb_.AddElement<int16_t>(TblUnitInfo2::VT_PURGEFORCE, purgeForce, 0);
  }
  void add_inwaferCoor(const stXY *inwaferCoor) {
    fbb_.AddStruct(TblUnitInfo2::VT_INWAFERCOOR, inwaferCoor);
  }
  void add_outwaferCoor(const stXY *outwaferCoor) {
    fbb_.AddStruct(TblUnitInfo2::VT_OUTWAFERCOOR, outwaferCoor);
  }
  explicit TblUnitInfo2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TblUnitInfo2Builder &operator=(const TblUnitInfo2Builder &);
  flatbuffers::Offset<TblUnitInfo2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TblUnitInfo2>(end);
    return o;
  }
};

inline flatbuffers::Offset<TblUnitInfo2> CreateTblUnitInfo2(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t goodDie = 0,
    int32_t placedDie = 0,
    int16_t bincode = 0,
    const stRejCode *rejcode = 0,
    bool valid = false,
    uint8_t pnp = 0,
    int16_t pickForce = 0,
    int16_t placeForce = 0,
    int16_t purgeForce = 0,
    const stXY *inwaferCoor = 0,
    const stXY *outwaferCoor = 0) {
  TblUnitInfo2Builder builder_(_fbb);
  builder_.add_outwaferCoor(outwaferCoor);
  builder_.add_inwaferCoor(inwaferCoor);
  builder_.add_rejcode(rejcode);
  builder_.add_placedDie(placedDie);
  builder_.add_goodDie(goodDie);
  builder_.add_purgeForce(purgeForce);
  builder_.add_placeForce(placeForce);
  builder_.add_pickForce(pickForce);
  builder_.add_bincode(bincode);
  builder_.add_pnp(pnp);
  builder_.add_valid(valid);
  return builder_.Finish();
}

struct TblLotInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MACHINE = 4,
    VT_LOTNUM = 6,
    VT_PACKAGENAME = 8,
    VT_RECIPENAME = 10,
    VT_SHIFT = 12,
    VT_OPERATOR_ = 14
  };
  const flatbuffers::String *machine() const {
    return GetPointer<const flatbuffers::String *>(VT_MACHINE);
  }
  const flatbuffers::String *lotNum() const {
    return GetPointer<const flatbuffers::String *>(VT_LOTNUM);
  }
  const flatbuffers::String *packageName() const {
    return GetPointer<const flatbuffers::String *>(VT_PACKAGENAME);
  }
  const flatbuffers::String *recipeName() const {
    return GetPointer<const flatbuffers::String *>(VT_RECIPENAME);
  }
  const flatbuffers::String *shift() const {
    return GetPointer<const flatbuffers::String *>(VT_SHIFT);
  }
  const flatbuffers::String *operator_() const {
    return GetPointer<const flatbuffers::String *>(VT_OPERATOR_);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MACHINE) &&
           verifier.VerifyString(machine()) &&
           VerifyOffset(verifier, VT_LOTNUM) &&
           verifier.VerifyString(lotNum()) &&
           VerifyOffset(verifier, VT_PACKAGENAME) &&
           verifier.VerifyString(packageName()) &&
           VerifyOffset(verifier, VT_RECIPENAME) &&
           verifier.VerifyString(recipeName()) &&
           VerifyOffset(verifier, VT_SHIFT) &&
           verifier.VerifyString(shift()) &&
           VerifyOffset(verifier, VT_OPERATOR_) &&
           verifier.VerifyString(operator_()) &&
           verifier.EndTable();
  }
};

struct TblLotInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_machine(flatbuffers::Offset<flatbuffers::String> machine) {
    fbb_.AddOffset(TblLotInfo::VT_MACHINE, machine);
  }
  void add_lotNum(flatbuffers::Offset<flatbuffers::String> lotNum) {
    fbb_.AddOffset(TblLotInfo::VT_LOTNUM, lotNum);
  }
  void add_packageName(flatbuffers::Offset<flatbuffers::String> packageName) {
    fbb_.AddOffset(TblLotInfo::VT_PACKAGENAME, packageName);
  }
  void add_recipeName(flatbuffers::Offset<flatbuffers::String> recipeName) {
    fbb_.AddOffset(TblLotInfo::VT_RECIPENAME, recipeName);
  }
  void add_shift(flatbuffers::Offset<flatbuffers::String> shift) {
    fbb_.AddOffset(TblLotInfo::VT_SHIFT, shift);
  }
  void add_operator_(flatbuffers::Offset<flatbuffers::String> operator_) {
    fbb_.AddOffset(TblLotInfo::VT_OPERATOR_, operator_);
  }
  explicit TblLotInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TblLotInfoBuilder &operator=(const TblLotInfoBuilder &);
  flatbuffers::Offset<TblLotInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TblLotInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TblLotInfo> CreateTblLotInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> machine = 0,
    flatbuffers::Offset<flatbuffers::String> lotNum = 0,
    flatbuffers::Offset<flatbuffers::String> packageName = 0,
    flatbuffers::Offset<flatbuffers::String> recipeName = 0,
    flatbuffers::Offset<flatbuffers::String> shift = 0,
    flatbuffers::Offset<flatbuffers::String> operator_ = 0) {
  TblLotInfoBuilder builder_(_fbb);
  builder_.add_operator_(operator_);
  builder_.add_shift(shift);
  builder_.add_recipeName(recipeName);
  builder_.add_packageName(packageName);
  builder_.add_lotNum(lotNum);
  builder_.add_machine(machine);
  return builder_.Finish();
}

inline flatbuffers::Offset<TblLotInfo> CreateTblLotInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *machine = nullptr,
    const char *lotNum = nullptr,
    const char *packageName = nullptr,
    const char *recipeName = nullptr,
    const char *shift = nullptr,
    const char *operator_ = nullptr) {
  return MitMapType::CreateTblLotInfo(
      _fbb,
      machine ? _fbb.CreateString(machine) : 0,
      lotNum ? _fbb.CreateString(lotNum) : 0,
      packageName ? _fbb.CreateString(packageName) : 0,
      recipeName ? _fbb.CreateString(recipeName) : 0,
      shift ? _fbb.CreateString(shift) : 0,
      operator_ ? _fbb.CreateString(operator_) : 0);
}

struct TblWaferInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DIESIZE = 4,
    VT_NOTCH = 6,
    VT_TARGETDIE = 8,
    VT_WAFERID = 10,
    VT_WAFERSIZE = 12,
    VT_MAXROWCOL = 14,
    VT_DIEGAP = 16,
    VT_EDGECLEARANCE = 18,
    VT_PICKDEGREE = 20,
    VT_DEGROTATED = 22,
    VT_REFDIE = 24,
    VT_REFCHIPDIR = 26,
    VT_WAFERFAB = 28,
    VT_FABCODE = 30,
    VT_INTCODE = 32,
    VT_DEVICE = 34,
    VT_DESIGNID = 36,
    VT_LAYOUT = 38,
    VT_SCRIBID = 40,
    VT_SCRIBLOT = 42,
    VT_MAPID = 44,
    VT_STARTLOC = 46,
    VT_NULLBIN = 48,
    VT_BINCODEFORMAT = 50
  };
  const stfXY *dieSize() const {
    return GetStruct<const stfXY *>(VT_DIESIZE);
  }
  int16_t notch() const {
    return GetField<int16_t>(VT_NOTCH, 0);
  }
  const flatbuffers::Vector<const stXY *> *targetDie() const {
    return GetPointer<const flatbuffers::Vector<const stXY *> *>(VT_TARGETDIE);
  }
  const flatbuffers::String *waferId() const {
    return GetPointer<const flatbuffers::String *>(VT_WAFERID);
  }
  float wafersize() const {
    return GetField<float>(VT_WAFERSIZE, 200.0f);
  }
  const stXY *maxRowCol() const {
    return GetStruct<const stXY *>(VT_MAXROWCOL);
  }
  const stfXY *dieGap() const {
    return GetStruct<const stfXY *>(VT_DIEGAP);
  }
  float edgeClearance() const {
    return GetField<float>(VT_EDGECLEARANCE, 5.0f);
  }
  int16_t pickDegree() const {
    return GetField<int16_t>(VT_PICKDEGREE, 0);
  }
  int16_t degRotated() const {
    return GetField<int16_t>(VT_DEGROTATED, 0);
  }
  const flatbuffers::Vector<const stXY *> *refDie() const {
    return GetPointer<const flatbuffers::Vector<const stXY *> *>(VT_REFDIE);
  }
  int16_t refChipDir() const {
    return GetField<int16_t>(VT_REFCHIPDIR, 0);
  }
  const flatbuffers::String *waferFab() const {
    return GetPointer<const flatbuffers::String *>(VT_WAFERFAB);
  }
  const flatbuffers::String *fabCode() const {
    return GetPointer<const flatbuffers::String *>(VT_FABCODE);
  }
  const flatbuffers::String *intCode() const {
    return GetPointer<const flatbuffers::String *>(VT_INTCODE);
  }
  const flatbuffers::String *device() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICE);
  }
  const flatbuffers::String *designId() const {
    return GetPointer<const flatbuffers::String *>(VT_DESIGNID);
  }
  const flatbuffers::String *layout() const {
    return GetPointer<const flatbuffers::String *>(VT_LAYOUT);
  }
  const flatbuffers::String *scribId() const {
    return GetPointer<const flatbuffers::String *>(VT_SCRIBID);
  }
  const flatbuffers::String *scribLot() const {
    return GetPointer<const flatbuffers::String *>(VT_SCRIBLOT);
  }
  int16_t mapId() const {
    return GetField<int16_t>(VT_MAPID, 0);
  }
  const stXY *startLoc() const {
    return GetStruct<const stXY *>(VT_STARTLOC);
  }
  int16_t nullBin() const {
    return GetField<int16_t>(VT_NULLBIN, 0);
  }
  format bincodeFormat() const {
    return static_cast<format>(GetField<int8_t>(VT_BINCODEFORMAT, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<stfXY>(verifier, VT_DIESIZE) &&
           VerifyField<int16_t>(verifier, VT_NOTCH) &&
           VerifyOffset(verifier, VT_TARGETDIE) &&
           verifier.VerifyVector(targetDie()) &&
           VerifyOffset(verifier, VT_WAFERID) &&
           verifier.VerifyString(waferId()) &&
           VerifyField<float>(verifier, VT_WAFERSIZE) &&
           VerifyField<stXY>(verifier, VT_MAXROWCOL) &&
           VerifyField<stfXY>(verifier, VT_DIEGAP) &&
           VerifyField<float>(verifier, VT_EDGECLEARANCE) &&
           VerifyField<int16_t>(verifier, VT_PICKDEGREE) &&
           VerifyField<int16_t>(verifier, VT_DEGROTATED) &&
           VerifyOffset(verifier, VT_REFDIE) &&
           verifier.VerifyVector(refDie()) &&
           VerifyField<int16_t>(verifier, VT_REFCHIPDIR) &&
           VerifyOffset(verifier, VT_WAFERFAB) &&
           verifier.VerifyString(waferFab()) &&
           VerifyOffset(verifier, VT_FABCODE) &&
           verifier.VerifyString(fabCode()) &&
           VerifyOffset(verifier, VT_INTCODE) &&
           verifier.VerifyString(intCode()) &&
           VerifyOffset(verifier, VT_DEVICE) &&
           verifier.VerifyString(device()) &&
           VerifyOffset(verifier, VT_DESIGNID) &&
           verifier.VerifyString(designId()) &&
           VerifyOffset(verifier, VT_LAYOUT) &&
           verifier.VerifyString(layout()) &&
           VerifyOffset(verifier, VT_SCRIBID) &&
           verifier.VerifyString(scribId()) &&
           VerifyOffset(verifier, VT_SCRIBLOT) &&
           verifier.VerifyString(scribLot()) &&
           VerifyField<int16_t>(verifier, VT_MAPID) &&
           VerifyField<stXY>(verifier, VT_STARTLOC) &&
           VerifyField<int16_t>(verifier, VT_NULLBIN) &&
           VerifyField<int8_t>(verifier, VT_BINCODEFORMAT) &&
           verifier.EndTable();
  }
};

struct TblWaferInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dieSize(const stfXY *dieSize) {
    fbb_.AddStruct(TblWaferInfo::VT_DIESIZE, dieSize);
  }
  void add_notch(int16_t notch) {
    fbb_.AddElement<int16_t>(TblWaferInfo::VT_NOTCH, notch, 0);
  }
  void add_targetDie(flatbuffers::Offset<flatbuffers::Vector<const stXY *>> targetDie) {
    fbb_.AddOffset(TblWaferInfo::VT_TARGETDIE, targetDie);
  }
  void add_waferId(flatbuffers::Offset<flatbuffers::String> waferId) {
    fbb_.AddOffset(TblWaferInfo::VT_WAFERID, waferId);
  }
  void add_wafersize(float wafersize) {
    fbb_.AddElement<float>(TblWaferInfo::VT_WAFERSIZE, wafersize, 200.0f);
  }
  void add_maxRowCol(const stXY *maxRowCol) {
    fbb_.AddStruct(TblWaferInfo::VT_MAXROWCOL, maxRowCol);
  }
  void add_dieGap(const stfXY *dieGap) {
    fbb_.AddStruct(TblWaferInfo::VT_DIEGAP, dieGap);
  }
  void add_edgeClearance(float edgeClearance) {
    fbb_.AddElement<float>(TblWaferInfo::VT_EDGECLEARANCE, edgeClearance, 5.0f);
  }
  void add_pickDegree(int16_t pickDegree) {
    fbb_.AddElement<int16_t>(TblWaferInfo::VT_PICKDEGREE, pickDegree, 0);
  }
  void add_degRotated(int16_t degRotated) {
    fbb_.AddElement<int16_t>(TblWaferInfo::VT_DEGROTATED, degRotated, 0);
  }
  void add_refDie(flatbuffers::Offset<flatbuffers::Vector<const stXY *>> refDie) {
    fbb_.AddOffset(TblWaferInfo::VT_REFDIE, refDie);
  }
  void add_refChipDir(int16_t refChipDir) {
    fbb_.AddElement<int16_t>(TblWaferInfo::VT_REFCHIPDIR, refChipDir, 0);
  }
  void add_waferFab(flatbuffers::Offset<flatbuffers::String> waferFab) {
    fbb_.AddOffset(TblWaferInfo::VT_WAFERFAB, waferFab);
  }
  void add_fabCode(flatbuffers::Offset<flatbuffers::String> fabCode) {
    fbb_.AddOffset(TblWaferInfo::VT_FABCODE, fabCode);
  }
  void add_intCode(flatbuffers::Offset<flatbuffers::String> intCode) {
    fbb_.AddOffset(TblWaferInfo::VT_INTCODE, intCode);
  }
  void add_device(flatbuffers::Offset<flatbuffers::String> device) {
    fbb_.AddOffset(TblWaferInfo::VT_DEVICE, device);
  }
  void add_designId(flatbuffers::Offset<flatbuffers::String> designId) {
    fbb_.AddOffset(TblWaferInfo::VT_DESIGNID, designId);
  }
  void add_layout(flatbuffers::Offset<flatbuffers::String> layout) {
    fbb_.AddOffset(TblWaferInfo::VT_LAYOUT, layout);
  }
  void add_scribId(flatbuffers::Offset<flatbuffers::String> scribId) {
    fbb_.AddOffset(TblWaferInfo::VT_SCRIBID, scribId);
  }
  void add_scribLot(flatbuffers::Offset<flatbuffers::String> scribLot) {
    fbb_.AddOffset(TblWaferInfo::VT_SCRIBLOT, scribLot);
  }
  void add_mapId(int16_t mapId) {
    fbb_.AddElement<int16_t>(TblWaferInfo::VT_MAPID, mapId, 0);
  }
  void add_startLoc(const stXY *startLoc) {
    fbb_.AddStruct(TblWaferInfo::VT_STARTLOC, startLoc);
  }
  void add_nullBin(int16_t nullBin) {
    fbb_.AddElement<int16_t>(TblWaferInfo::VT_NULLBIN, nullBin, 0);
  }
  void add_bincodeFormat(format bincodeFormat) {
    fbb_.AddElement<int8_t>(TblWaferInfo::VT_BINCODEFORMAT, static_cast<int8_t>(bincodeFormat), 2);
  }
  explicit TblWaferInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TblWaferInfoBuilder &operator=(const TblWaferInfoBuilder &);
  flatbuffers::Offset<TblWaferInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TblWaferInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TblWaferInfo> CreateTblWaferInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    const stfXY *dieSize = 0,
    int16_t notch = 0,
    flatbuffers::Offset<flatbuffers::Vector<const stXY *>> targetDie = 0,
    flatbuffers::Offset<flatbuffers::String> waferId = 0,
    float wafersize = 200.0f,
    const stXY *maxRowCol = 0,
    const stfXY *dieGap = 0,
    float edgeClearance = 5.0f,
    int16_t pickDegree = 0,
    int16_t degRotated = 0,
    flatbuffers::Offset<flatbuffers::Vector<const stXY *>> refDie = 0,
    int16_t refChipDir = 0,
    flatbuffers::Offset<flatbuffers::String> waferFab = 0,
    flatbuffers::Offset<flatbuffers::String> fabCode = 0,
    flatbuffers::Offset<flatbuffers::String> intCode = 0,
    flatbuffers::Offset<flatbuffers::String> device = 0,
    flatbuffers::Offset<flatbuffers::String> designId = 0,
    flatbuffers::Offset<flatbuffers::String> layout = 0,
    flatbuffers::Offset<flatbuffers::String> scribId = 0,
    flatbuffers::Offset<flatbuffers::String> scribLot = 0,
    int16_t mapId = 0,
    const stXY *startLoc = 0,
    int16_t nullBin = 0,
    format bincodeFormat = format_Hex) {
  TblWaferInfoBuilder builder_(_fbb);
  builder_.add_startLoc(startLoc);
  builder_.add_scribLot(scribLot);
  builder_.add_scribId(scribId);
  builder_.add_layout(layout);
  builder_.add_designId(designId);
  builder_.add_device(device);
  builder_.add_intCode(intCode);
  builder_.add_fabCode(fabCode);
  builder_.add_waferFab(waferFab);
  builder_.add_refDie(refDie);
  builder_.add_edgeClearance(edgeClearance);
  builder_.add_dieGap(dieGap);
  builder_.add_maxRowCol(maxRowCol);
  builder_.add_wafersize(wafersize);
  builder_.add_waferId(waferId);
  builder_.add_targetDie(targetDie);
  builder_.add_dieSize(dieSize);
  builder_.add_nullBin(nullBin);
  builder_.add_mapId(mapId);
  builder_.add_refChipDir(refChipDir);
  builder_.add_degRotated(degRotated);
  builder_.add_pickDegree(pickDegree);
  builder_.add_notch(notch);
  builder_.add_bincodeFormat(bincodeFormat);
  return builder_.Finish();
}

inline flatbuffers::Offset<TblWaferInfo> CreateTblWaferInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const stfXY *dieSize = 0,
    int16_t notch = 0,
    const std::vector<stXY> *targetDie = nullptr,
    const char *waferId = nullptr,
    float wafersize = 200.0f,
    const stXY *maxRowCol = 0,
    const stfXY *dieGap = 0,
    float edgeClearance = 5.0f,
    int16_t pickDegree = 0,
    int16_t degRotated = 0,
    const std::vector<stXY> *refDie = nullptr,
    int16_t refChipDir = 0,
    const char *waferFab = nullptr,
    const char *fabCode = nullptr,
    const char *intCode = nullptr,
    const char *device = nullptr,
    const char *designId = nullptr,
    const char *layout = nullptr,
    const char *scribId = nullptr,
    const char *scribLot = nullptr,
    int16_t mapId = 0,
    const stXY *startLoc = 0,
    int16_t nullBin = 0,
    format bincodeFormat = format_Hex) {
  return MitMapType::CreateTblWaferInfo(
      _fbb,
      dieSize,
      notch,
      targetDie ? _fbb.CreateVectorOfStructs<stXY>(*targetDie) : 0,
      waferId ? _fbb.CreateString(waferId) : 0,
      wafersize,
      maxRowCol,
      dieGap,
      edgeClearance,
      pickDegree,
      degRotated,
      refDie ? _fbb.CreateVectorOfStructs<stXY>(*refDie) : 0,
      refChipDir,
      waferFab ? _fbb.CreateString(waferFab) : 0,
      fabCode ? _fbb.CreateString(fabCode) : 0,
      intCode ? _fbb.CreateString(intCode) : 0,
      device ? _fbb.CreateString(device) : 0,
      designId ? _fbb.CreateString(designId) : 0,
      layout ? _fbb.CreateString(layout) : 0,
      scribId ? _fbb.CreateString(scribId) : 0,
      scribLot ? _fbb.CreateString(scribLot) : 0,
      mapId,
      startLoc,
      nullBin,
      bincodeFormat);
}

struct MapRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_LOTINFO = 6,
    VT_WAFERINFO = 8,
    VT_UNIT = 10,
    VT_ULT = 12,
    VT_ULT2 = 14,
    VT_TBLULT2 = 16
  };
  MapType type() const {
    return static_cast<MapType>(GetField<int8_t>(VT_TYPE, 1));
  }
  const TblLotInfo *lotInfo() const {
    return GetPointer<const TblLotInfo *>(VT_LOTINFO);
  }
  const TblWaferInfo *waferInfo() const {
    return GetPointer<const TblWaferInfo *>(VT_WAFERINFO);
  }
  const flatbuffers::Vector<int16_t> *unit() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_UNIT);
  }
  const flatbuffers::Vector<const stUnitInfo *> *ult() const {
    return GetPointer<const flatbuffers::Vector<const stUnitInfo *> *>(VT_ULT);
  }
  const flatbuffers::Vector<const stUnitInfo2 *> *ult2() const {
    return GetPointer<const flatbuffers::Vector<const stUnitInfo2 *> *>(VT_ULT2);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TblUnitInfo2>> *TblUlt2() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TblUnitInfo2>> *>(VT_TBLULT2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_LOTINFO) &&
           verifier.VerifyTable(lotInfo()) &&
           VerifyOffset(verifier, VT_WAFERINFO) &&
           verifier.VerifyTable(waferInfo()) &&
           VerifyOffset(verifier, VT_UNIT) &&
           verifier.VerifyVector(unit()) &&
           VerifyOffset(verifier, VT_ULT) &&
           verifier.VerifyVector(ult()) &&
           VerifyOffset(verifier, VT_ULT2) &&
           verifier.VerifyVector(ult2()) &&
           VerifyOffset(verifier, VT_TBLULT2) &&
           verifier.VerifyVector(TblUlt2()) &&
           verifier.VerifyVectorOfTables(TblUlt2()) &&
           verifier.EndTable();
  }
};

struct MapRootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(MapType type) {
    fbb_.AddElement<int8_t>(MapRoot::VT_TYPE, static_cast<int8_t>(type), 1);
  }
  void add_lotInfo(flatbuffers::Offset<TblLotInfo> lotInfo) {
    fbb_.AddOffset(MapRoot::VT_LOTINFO, lotInfo);
  }
  void add_waferInfo(flatbuffers::Offset<TblWaferInfo> waferInfo) {
    fbb_.AddOffset(MapRoot::VT_WAFERINFO, waferInfo);
  }
  void add_unit(flatbuffers::Offset<flatbuffers::Vector<int16_t>> unit) {
    fbb_.AddOffset(MapRoot::VT_UNIT, unit);
  }
  void add_ult(flatbuffers::Offset<flatbuffers::Vector<const stUnitInfo *>> ult) {
    fbb_.AddOffset(MapRoot::VT_ULT, ult);
  }
  void add_ult2(flatbuffers::Offset<flatbuffers::Vector<const stUnitInfo2 *>> ult2) {
    fbb_.AddOffset(MapRoot::VT_ULT2, ult2);
  }
  void add_TblUlt2(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TblUnitInfo2>>> TblUlt2) {
    fbb_.AddOffset(MapRoot::VT_TBLULT2, TblUlt2);
  }
  explicit MapRootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapRootBuilder &operator=(const MapRootBuilder &);
  flatbuffers::Offset<MapRoot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapRoot>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapRoot> CreateMapRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    MapType type = MapType_MAP_ULT_C330,
    flatbuffers::Offset<TblLotInfo> lotInfo = 0,
    flatbuffers::Offset<TblWaferInfo> waferInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> unit = 0,
    flatbuffers::Offset<flatbuffers::Vector<const stUnitInfo *>> ult = 0,
    flatbuffers::Offset<flatbuffers::Vector<const stUnitInfo2 *>> ult2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TblUnitInfo2>>> TblUlt2 = 0) {
  MapRootBuilder builder_(_fbb);
  builder_.add_TblUlt2(TblUlt2);
  builder_.add_ult2(ult2);
  builder_.add_ult(ult);
  builder_.add_unit(unit);
  builder_.add_waferInfo(waferInfo);
  builder_.add_lotInfo(lotInfo);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapRoot> CreateMapRootDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    MapType type = MapType_MAP_ULT_C330,
    flatbuffers::Offset<TblLotInfo> lotInfo = 0,
    flatbuffers::Offset<TblWaferInfo> waferInfo = 0,
    const std::vector<int16_t> *unit = nullptr,
    const std::vector<stUnitInfo> *ult = nullptr,
    const std::vector<stUnitInfo2> *ult2 = nullptr,
    const std::vector<flatbuffers::Offset<TblUnitInfo2>> *TblUlt2 = nullptr) {
  return MitMapType::CreateMapRoot(
      _fbb,
      type,
      lotInfo,
      waferInfo,
      unit ? _fbb.CreateVector<int16_t>(*unit) : 0,
      ult ? _fbb.CreateVectorOfStructs<stUnitInfo>(*ult) : 0,
      ult2 ? _fbb.CreateVectorOfStructs<stUnitInfo2>(*ult2) : 0,
      TblUlt2 ? _fbb.CreateVector<flatbuffers::Offset<TblUnitInfo2>>(*TblUlt2) : 0);
}

inline const MitMapType::MapRoot *GetMapRoot(const void *buf) {
  return flatbuffers::GetRoot<MitMapType::MapRoot>(buf);
}

inline const MitMapType::MapRoot *GetSizePrefixedMapRoot(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<MitMapType::MapRoot>(buf);
}

inline bool VerifyMapRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MitMapType::MapRoot>(nullptr);
}

inline bool VerifySizePrefixedMapRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MitMapType::MapRoot>(nullptr);
}

inline void FinishMapRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MitMapType::MapRoot> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMapRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MitMapType::MapRoot> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace MitMapType

#endif  // FLATBUFFERS_GENERATED_MITMAPTYPE_MITMAPTYPE_H_
