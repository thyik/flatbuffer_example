// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MITMAPTYPE_MITMAPTYPE_H_
#define FLATBUFFERS_GENERATED_MITMAPTYPE_MITMAPTYPE_H_

#include "flatbuffers/flatbuffers.h"

namespace MitMapType {

struct stXY;

struct stfXY;

struct stfOFFSET;

struct stRejCode;

struct stUnitInfo;

struct TblUnitInfo2;

struct TblLotInfo;

struct TblWaferInfo;

struct MapRoot;

enum MapType {
  MapType_MAP_GENERIC = 0,
  MapType_MAP_ULT_C330 = 1,
  MapType_MAP_ULT_MR3 = 2,
  MapType_MIN = MapType_MAP_GENERIC,
  MapType_MAX = MapType_MAP_ULT_MR3
};

inline const MapType (&EnumValuesMapType())[3] {
  static const MapType values[] = {
    MapType_MAP_GENERIC,
    MapType_MAP_ULT_C330,
    MapType_MAP_ULT_MR3
  };
  return values;
}

inline const char * const *EnumNamesMapType() {
  static const char * const names[] = {
    "MAP_GENERIC",
    "MAP_ULT_C330",
    "MAP_ULT_MR3",
    nullptr
  };
  return names;
}

inline const char *EnumNameMapType(MapType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMapType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) stXY FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t x_;
  int16_t y_;

 public:
  stXY() {
    memset(this, 0, sizeof(stXY));
  }
  stXY(int16_t _x, int16_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int16_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int16_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(stXY, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) stfXY FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  stfXY() {
    memset(this, 0, sizeof(stfXY));
  }
  stfXY(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(stfXY, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) stfOFFSET FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float a_;

 public:
  stfOFFSET() {
    memset(this, 0, sizeof(stfOFFSET));
  }
  stfOFFSET(float _x, float _y, float _a)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(stfOFFSET, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) stRejCode FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t pc_;
  uint8_t app_;
  uint8_t code_;

 public:
  stRejCode() {
    memset(this, 0, sizeof(stRejCode));
  }
  stRejCode(uint8_t _pc, uint8_t _app, uint8_t _code)
      : pc_(flatbuffers::EndianScalar(_pc)),
        app_(flatbuffers::EndianScalar(_app)),
        code_(flatbuffers::EndianScalar(_code)) {
  }
  uint8_t pc() const {
    return flatbuffers::EndianScalar(pc_);
  }
  uint8_t app() const {
    return flatbuffers::EndianScalar(app_);
  }
  uint8_t code() const {
    return flatbuffers::EndianScalar(code_);
  }
};
FLATBUFFERS_STRUCT_END(stRejCode, 3);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) stUnitInfo FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t pocket_;
  int16_t reel_;
  int16_t bincode_;
  stRejCode rejcode_;
  uint8_t valid_;

 public:
  stUnitInfo() {
    memset(this, 0, sizeof(stUnitInfo));
  }
  stUnitInfo(int32_t _pocket, int16_t _reel, int16_t _bincode, const stRejCode &_rejcode, bool _valid)
      : pocket_(flatbuffers::EndianScalar(_pocket)),
        reel_(flatbuffers::EndianScalar(_reel)),
        bincode_(flatbuffers::EndianScalar(_bincode)),
        rejcode_(_rejcode),
        valid_(flatbuffers::EndianScalar(static_cast<uint8_t>(_valid))) {
  }
  int32_t pocket() const {
    return flatbuffers::EndianScalar(pocket_);
  }
  int16_t reel() const {
    return flatbuffers::EndianScalar(reel_);
  }
  int16_t bincode() const {
    return flatbuffers::EndianScalar(bincode_);
  }
  const stRejCode &rejcode() const {
    return rejcode_;
  }
  bool valid() const {
    return flatbuffers::EndianScalar(valid_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(stUnitInfo, 12);

struct TblUnitInfo2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POCKET = 4,
    VT_REEL = 6,
    VT_BINCODE = 8,
    VT_REJCODE = 10,
    VT_VALID = 12,
    VT_INWAFERID = 14,
    VT_INWAFERCOOR = 16,
    VT_OUTWAFERID = 18,
    VT_OUTWAFERCOOR = 20
  };
  int32_t pocket() const {
    return GetField<int32_t>(VT_POCKET, 0);
  }
  int16_t reel() const {
    return GetField<int16_t>(VT_REEL, 0);
  }
  int16_t bincode() const {
    return GetField<int16_t>(VT_BINCODE, 0);
  }
  const stRejCode *rejcode() const {
    return GetStruct<const stRejCode *>(VT_REJCODE);
  }
  bool valid() const {
    return GetField<uint8_t>(VT_VALID, 0) != 0;
  }
  const flatbuffers::String *inwaferid() const {
    return GetPointer<const flatbuffers::String *>(VT_INWAFERID);
  }
  const stXY *inwaferCoor() const {
    return GetStruct<const stXY *>(VT_INWAFERCOOR);
  }
  const flatbuffers::String *outwaferid() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTWAFERID);
  }
  const stXY *outwaferCoor() const {
    return GetStruct<const stXY *>(VT_OUTWAFERCOOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POCKET) &&
           VerifyField<int16_t>(verifier, VT_REEL) &&
           VerifyField<int16_t>(verifier, VT_BINCODE) &&
           VerifyField<stRejCode>(verifier, VT_REJCODE) &&
           VerifyField<uint8_t>(verifier, VT_VALID) &&
           VerifyOffset(verifier, VT_INWAFERID) &&
           verifier.VerifyString(inwaferid()) &&
           VerifyField<stXY>(verifier, VT_INWAFERCOOR) &&
           VerifyOffset(verifier, VT_OUTWAFERID) &&
           verifier.VerifyString(outwaferid()) &&
           VerifyField<stXY>(verifier, VT_OUTWAFERCOOR) &&
           verifier.EndTable();
  }
};

struct TblUnitInfo2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pocket(int32_t pocket) {
    fbb_.AddElement<int32_t>(TblUnitInfo2::VT_POCKET, pocket, 0);
  }
  void add_reel(int16_t reel) {
    fbb_.AddElement<int16_t>(TblUnitInfo2::VT_REEL, reel, 0);
  }
  void add_bincode(int16_t bincode) {
    fbb_.AddElement<int16_t>(TblUnitInfo2::VT_BINCODE, bincode, 0);
  }
  void add_rejcode(const stRejCode *rejcode) {
    fbb_.AddStruct(TblUnitInfo2::VT_REJCODE, rejcode);
  }
  void add_valid(bool valid) {
    fbb_.AddElement<uint8_t>(TblUnitInfo2::VT_VALID, static_cast<uint8_t>(valid), 0);
  }
  void add_inwaferid(flatbuffers::Offset<flatbuffers::String> inwaferid) {
    fbb_.AddOffset(TblUnitInfo2::VT_INWAFERID, inwaferid);
  }
  void add_inwaferCoor(const stXY *inwaferCoor) {
    fbb_.AddStruct(TblUnitInfo2::VT_INWAFERCOOR, inwaferCoor);
  }
  void add_outwaferid(flatbuffers::Offset<flatbuffers::String> outwaferid) {
    fbb_.AddOffset(TblUnitInfo2::VT_OUTWAFERID, outwaferid);
  }
  void add_outwaferCoor(const stXY *outwaferCoor) {
    fbb_.AddStruct(TblUnitInfo2::VT_OUTWAFERCOOR, outwaferCoor);
  }
  explicit TblUnitInfo2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TblUnitInfo2Builder &operator=(const TblUnitInfo2Builder &);
  flatbuffers::Offset<TblUnitInfo2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TblUnitInfo2>(end);
    return o;
  }
};

inline flatbuffers::Offset<TblUnitInfo2> CreateTblUnitInfo2(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pocket = 0,
    int16_t reel = 0,
    int16_t bincode = 0,
    const stRejCode *rejcode = 0,
    bool valid = false,
    flatbuffers::Offset<flatbuffers::String> inwaferid = 0,
    const stXY *inwaferCoor = 0,
    flatbuffers::Offset<flatbuffers::String> outwaferid = 0,
    const stXY *outwaferCoor = 0) {
  TblUnitInfo2Builder builder_(_fbb);
  builder_.add_outwaferCoor(outwaferCoor);
  builder_.add_outwaferid(outwaferid);
  builder_.add_inwaferCoor(inwaferCoor);
  builder_.add_inwaferid(inwaferid);
  builder_.add_rejcode(rejcode);
  builder_.add_pocket(pocket);
  builder_.add_bincode(bincode);
  builder_.add_reel(reel);
  builder_.add_valid(valid);
  return builder_.Finish();
}

inline flatbuffers::Offset<TblUnitInfo2> CreateTblUnitInfo2Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pocket = 0,
    int16_t reel = 0,
    int16_t bincode = 0,
    const stRejCode *rejcode = 0,
    bool valid = false,
    const char *inwaferid = nullptr,
    const stXY *inwaferCoor = 0,
    const char *outwaferid = nullptr,
    const stXY *outwaferCoor = 0) {
  return MitMapType::CreateTblUnitInfo2(
      _fbb,
      pocket,
      reel,
      bincode,
      rejcode,
      valid,
      inwaferid ? _fbb.CreateString(inwaferid) : 0,
      inwaferCoor,
      outwaferid ? _fbb.CreateString(outwaferid) : 0,
      outwaferCoor);
}

struct TblLotInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MACHINE = 4,
    VT_LOTNUM = 6,
    VT_PACKAGENAME = 8,
    VT_RECIPENAME = 10,
    VT_SHIFT = 12,
    VT_OPERATOR_ = 14
  };
  const flatbuffers::String *machine() const {
    return GetPointer<const flatbuffers::String *>(VT_MACHINE);
  }
  const flatbuffers::String *lotNum() const {
    return GetPointer<const flatbuffers::String *>(VT_LOTNUM);
  }
  const flatbuffers::String *packageName() const {
    return GetPointer<const flatbuffers::String *>(VT_PACKAGENAME);
  }
  const flatbuffers::String *recipeName() const {
    return GetPointer<const flatbuffers::String *>(VT_RECIPENAME);
  }
  const flatbuffers::String *shift() const {
    return GetPointer<const flatbuffers::String *>(VT_SHIFT);
  }
  const flatbuffers::String *operator_() const {
    return GetPointer<const flatbuffers::String *>(VT_OPERATOR_);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MACHINE) &&
           verifier.VerifyString(machine()) &&
           VerifyOffset(verifier, VT_LOTNUM) &&
           verifier.VerifyString(lotNum()) &&
           VerifyOffset(verifier, VT_PACKAGENAME) &&
           verifier.VerifyString(packageName()) &&
           VerifyOffset(verifier, VT_RECIPENAME) &&
           verifier.VerifyString(recipeName()) &&
           VerifyOffset(verifier, VT_SHIFT) &&
           verifier.VerifyString(shift()) &&
           VerifyOffset(verifier, VT_OPERATOR_) &&
           verifier.VerifyString(operator_()) &&
           verifier.EndTable();
  }
};

struct TblLotInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_machine(flatbuffers::Offset<flatbuffers::String> machine) {
    fbb_.AddOffset(TblLotInfo::VT_MACHINE, machine);
  }
  void add_lotNum(flatbuffers::Offset<flatbuffers::String> lotNum) {
    fbb_.AddOffset(TblLotInfo::VT_LOTNUM, lotNum);
  }
  void add_packageName(flatbuffers::Offset<flatbuffers::String> packageName) {
    fbb_.AddOffset(TblLotInfo::VT_PACKAGENAME, packageName);
  }
  void add_recipeName(flatbuffers::Offset<flatbuffers::String> recipeName) {
    fbb_.AddOffset(TblLotInfo::VT_RECIPENAME, recipeName);
  }
  void add_shift(flatbuffers::Offset<flatbuffers::String> shift) {
    fbb_.AddOffset(TblLotInfo::VT_SHIFT, shift);
  }
  void add_operator_(flatbuffers::Offset<flatbuffers::String> operator_) {
    fbb_.AddOffset(TblLotInfo::VT_OPERATOR_, operator_);
  }
  explicit TblLotInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TblLotInfoBuilder &operator=(const TblLotInfoBuilder &);
  flatbuffers::Offset<TblLotInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TblLotInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TblLotInfo> CreateTblLotInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> machine = 0,
    flatbuffers::Offset<flatbuffers::String> lotNum = 0,
    flatbuffers::Offset<flatbuffers::String> packageName = 0,
    flatbuffers::Offset<flatbuffers::String> recipeName = 0,
    flatbuffers::Offset<flatbuffers::String> shift = 0,
    flatbuffers::Offset<flatbuffers::String> operator_ = 0) {
  TblLotInfoBuilder builder_(_fbb);
  builder_.add_operator_(operator_);
  builder_.add_shift(shift);
  builder_.add_recipeName(recipeName);
  builder_.add_packageName(packageName);
  builder_.add_lotNum(lotNum);
  builder_.add_machine(machine);
  return builder_.Finish();
}

inline flatbuffers::Offset<TblLotInfo> CreateTblLotInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *machine = nullptr,
    const char *lotNum = nullptr,
    const char *packageName = nullptr,
    const char *recipeName = nullptr,
    const char *shift = nullptr,
    const char *operator_ = nullptr) {
  return MitMapType::CreateTblLotInfo(
      _fbb,
      machine ? _fbb.CreateString(machine) : 0,
      lotNum ? _fbb.CreateString(lotNum) : 0,
      packageName ? _fbb.CreateString(packageName) : 0,
      recipeName ? _fbb.CreateString(recipeName) : 0,
      shift ? _fbb.CreateString(shift) : 0,
      operator_ ? _fbb.CreateString(operator_) : 0);
}

struct TblWaferInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DIESIZE = 4,
    VT_NOTCH = 6,
    VT_TARGETDIE = 8,
    VT_WAFERID = 10,
    VT_WAFERSIZE = 12,
    VT_MAXROWCOL = 14,
    VT_DIEGAP = 16
  };
  const stfXY *dieSize() const {
    return GetStruct<const stfXY *>(VT_DIESIZE);
  }
  int16_t notch() const {
    return GetField<int16_t>(VT_NOTCH, 0);
  }
  const flatbuffers::Vector<const stXY *> *targetDie() const {
    return GetPointer<const flatbuffers::Vector<const stXY *> *>(VT_TARGETDIE);
  }
  const flatbuffers::String *waferId() const {
    return GetPointer<const flatbuffers::String *>(VT_WAFERID);
  }
  float wafersize() const {
    return GetField<float>(VT_WAFERSIZE, 200.0f);
  }
  const stXY *maxRowCol() const {
    return GetStruct<const stXY *>(VT_MAXROWCOL);
  }
  const stfXY *dieGap() const {
    return GetStruct<const stfXY *>(VT_DIEGAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<stfXY>(verifier, VT_DIESIZE) &&
           VerifyField<int16_t>(verifier, VT_NOTCH) &&
           VerifyOffset(verifier, VT_TARGETDIE) &&
           verifier.VerifyVector(targetDie()) &&
           VerifyOffset(verifier, VT_WAFERID) &&
           verifier.VerifyString(waferId()) &&
           VerifyField<float>(verifier, VT_WAFERSIZE) &&
           VerifyField<stXY>(verifier, VT_MAXROWCOL) &&
           VerifyField<stfXY>(verifier, VT_DIEGAP) &&
           verifier.EndTable();
  }
};

struct TblWaferInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dieSize(const stfXY *dieSize) {
    fbb_.AddStruct(TblWaferInfo::VT_DIESIZE, dieSize);
  }
  void add_notch(int16_t notch) {
    fbb_.AddElement<int16_t>(TblWaferInfo::VT_NOTCH, notch, 0);
  }
  void add_targetDie(flatbuffers::Offset<flatbuffers::Vector<const stXY *>> targetDie) {
    fbb_.AddOffset(TblWaferInfo::VT_TARGETDIE, targetDie);
  }
  void add_waferId(flatbuffers::Offset<flatbuffers::String> waferId) {
    fbb_.AddOffset(TblWaferInfo::VT_WAFERID, waferId);
  }
  void add_wafersize(float wafersize) {
    fbb_.AddElement<float>(TblWaferInfo::VT_WAFERSIZE, wafersize, 200.0f);
  }
  void add_maxRowCol(const stXY *maxRowCol) {
    fbb_.AddStruct(TblWaferInfo::VT_MAXROWCOL, maxRowCol);
  }
  void add_dieGap(const stfXY *dieGap) {
    fbb_.AddStruct(TblWaferInfo::VT_DIEGAP, dieGap);
  }
  explicit TblWaferInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TblWaferInfoBuilder &operator=(const TblWaferInfoBuilder &);
  flatbuffers::Offset<TblWaferInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TblWaferInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TblWaferInfo> CreateTblWaferInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    const stfXY *dieSize = 0,
    int16_t notch = 0,
    flatbuffers::Offset<flatbuffers::Vector<const stXY *>> targetDie = 0,
    flatbuffers::Offset<flatbuffers::String> waferId = 0,
    float wafersize = 200.0f,
    const stXY *maxRowCol = 0,
    const stfXY *dieGap = 0) {
  TblWaferInfoBuilder builder_(_fbb);
  builder_.add_dieGap(dieGap);
  builder_.add_maxRowCol(maxRowCol);
  builder_.add_wafersize(wafersize);
  builder_.add_waferId(waferId);
  builder_.add_targetDie(targetDie);
  builder_.add_dieSize(dieSize);
  builder_.add_notch(notch);
  return builder_.Finish();
}

inline flatbuffers::Offset<TblWaferInfo> CreateTblWaferInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const stfXY *dieSize = 0,
    int16_t notch = 0,
    const std::vector<stXY> *targetDie = nullptr,
    const char *waferId = nullptr,
    float wafersize = 200.0f,
    const stXY *maxRowCol = 0,
    const stfXY *dieGap = 0) {
  return MitMapType::CreateTblWaferInfo(
      _fbb,
      dieSize,
      notch,
      targetDie ? _fbb.CreateVectorOfStructs<stXY>(*targetDie) : 0,
      waferId ? _fbb.CreateString(waferId) : 0,
      wafersize,
      maxRowCol,
      dieGap);
}

struct MapRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_LOTINFO = 6,
    VT_WAFERINFO = 8,
    VT_UNIT = 10,
    VT_ULT = 12,
    VT_ULT2 = 14
  };
  MapType type() const {
    return static_cast<MapType>(GetField<int8_t>(VT_TYPE, 1));
  }
  const TblLotInfo *lotInfo() const {
    return GetPointer<const TblLotInfo *>(VT_LOTINFO);
  }
  const TblWaferInfo *waferInfo() const {
    return GetPointer<const TblWaferInfo *>(VT_WAFERINFO);
  }
  const flatbuffers::Vector<int16_t> *unit() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_UNIT);
  }
  const flatbuffers::Vector<const stUnitInfo *> *ult() const {
    return GetPointer<const flatbuffers::Vector<const stUnitInfo *> *>(VT_ULT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TblUnitInfo2>> *ult2() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TblUnitInfo2>> *>(VT_ULT2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_LOTINFO) &&
           verifier.VerifyTable(lotInfo()) &&
           VerifyOffset(verifier, VT_WAFERINFO) &&
           verifier.VerifyTable(waferInfo()) &&
           VerifyOffset(verifier, VT_UNIT) &&
           verifier.VerifyVector(unit()) &&
           VerifyOffset(verifier, VT_ULT) &&
           verifier.VerifyVector(ult()) &&
           VerifyOffset(verifier, VT_ULT2) &&
           verifier.VerifyVector(ult2()) &&
           verifier.VerifyVectorOfTables(ult2()) &&
           verifier.EndTable();
  }
};

struct MapRootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(MapType type) {
    fbb_.AddElement<int8_t>(MapRoot::VT_TYPE, static_cast<int8_t>(type), 1);
  }
  void add_lotInfo(flatbuffers::Offset<TblLotInfo> lotInfo) {
    fbb_.AddOffset(MapRoot::VT_LOTINFO, lotInfo);
  }
  void add_waferInfo(flatbuffers::Offset<TblWaferInfo> waferInfo) {
    fbb_.AddOffset(MapRoot::VT_WAFERINFO, waferInfo);
  }
  void add_unit(flatbuffers::Offset<flatbuffers::Vector<int16_t>> unit) {
    fbb_.AddOffset(MapRoot::VT_UNIT, unit);
  }
  void add_ult(flatbuffers::Offset<flatbuffers::Vector<const stUnitInfo *>> ult) {
    fbb_.AddOffset(MapRoot::VT_ULT, ult);
  }
  void add_ult2(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TblUnitInfo2>>> ult2) {
    fbb_.AddOffset(MapRoot::VT_ULT2, ult2);
  }
  explicit MapRootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapRootBuilder &operator=(const MapRootBuilder &);
  flatbuffers::Offset<MapRoot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapRoot>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapRoot> CreateMapRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    MapType type = MapType_MAP_ULT_C330,
    flatbuffers::Offset<TblLotInfo> lotInfo = 0,
    flatbuffers::Offset<TblWaferInfo> waferInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> unit = 0,
    flatbuffers::Offset<flatbuffers::Vector<const stUnitInfo *>> ult = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TblUnitInfo2>>> ult2 = 0) {
  MapRootBuilder builder_(_fbb);
  builder_.add_ult2(ult2);
  builder_.add_ult(ult);
  builder_.add_unit(unit);
  builder_.add_waferInfo(waferInfo);
  builder_.add_lotInfo(lotInfo);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapRoot> CreateMapRootDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    MapType type = MapType_MAP_ULT_C330,
    flatbuffers::Offset<TblLotInfo> lotInfo = 0,
    flatbuffers::Offset<TblWaferInfo> waferInfo = 0,
    const std::vector<int16_t> *unit = nullptr,
    const std::vector<stUnitInfo> *ult = nullptr,
    const std::vector<flatbuffers::Offset<TblUnitInfo2>> *ult2 = nullptr) {
  return MitMapType::CreateMapRoot(
      _fbb,
      type,
      lotInfo,
      waferInfo,
      unit ? _fbb.CreateVector<int16_t>(*unit) : 0,
      ult ? _fbb.CreateVectorOfStructs<stUnitInfo>(*ult) : 0,
      ult2 ? _fbb.CreateVector<flatbuffers::Offset<TblUnitInfo2>>(*ult2) : 0);
}

inline const MitMapType::MapRoot *GetMapRoot(const void *buf) {
  return flatbuffers::GetRoot<MitMapType::MapRoot>(buf);
}

inline const MitMapType::MapRoot *GetSizePrefixedMapRoot(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<MitMapType::MapRoot>(buf);
}

inline bool VerifyMapRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MitMapType::MapRoot>(nullptr);
}

inline bool VerifySizePrefixedMapRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MitMapType::MapRoot>(nullptr);
}

inline void FinishMapRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MitMapType::MapRoot> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMapRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MitMapType::MapRoot> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace MitMapType

#endif  // FLATBUFFERS_GENERATED_MITMAPTYPE_MITMAPTYPE_H_
