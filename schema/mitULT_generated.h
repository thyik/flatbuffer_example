// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MITULT_MITULT_H_
#define FLATBUFFERS_GENERATED_MITULT_MITULT_H_

#include "flatbuffers/flatbuffers.h"

namespace MitULT {

struct stXY;

struct stfXY;

struct stfOFFSET;

struct ultVISION;

struct ultLOT;

struct ultWAFER;

struct ultUNIT;

struct ultOBJECT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) stXY FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t x_;
  int16_t y_;

 public:
  stXY() {
    memset(this, 0, sizeof(stXY));
  }
  stXY(int16_t _x, int16_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int16_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int16_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(stXY, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) stfXY FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  stfXY() {
    memset(this, 0, sizeof(stfXY));
  }
  stfXY(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(stfXY, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) stfOFFSET FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float a_;

 public:
  stfOFFSET() {
    memset(this, 0, sizeof(stfOFFSET));
  }
  stfOFFSET(float _x, float _y, float _a)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(stfOFFSET, 12);

struct ultVISION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_DIEID = 6,
    VT_RESULT = 8,
    VT_DATETIME = 10,
    VT_OFFSET = 12
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *dieId() const {
    return GetPointer<const flatbuffers::String *>(VT_DIEID);
  }
  const flatbuffers::String *result() const {
    return GetPointer<const flatbuffers::String *>(VT_RESULT);
  }
  const flatbuffers::String *datetime() const {
    return GetPointer<const flatbuffers::String *>(VT_DATETIME);
  }
  const stfOFFSET *offset() const {
    return GetStruct<const stfOFFSET *>(VT_OFFSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_DIEID) &&
           verifier.VerifyString(dieId()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_DATETIME) &&
           verifier.VerifyString(datetime()) &&
           VerifyField<stfOFFSET>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct ultVISIONBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(ultVISION::VT_TYPE, type);
  }
  void add_dieId(flatbuffers::Offset<flatbuffers::String> dieId) {
    fbb_.AddOffset(ultVISION::VT_DIEID, dieId);
  }
  void add_result(flatbuffers::Offset<flatbuffers::String> result) {
    fbb_.AddOffset(ultVISION::VT_RESULT, result);
  }
  void add_datetime(flatbuffers::Offset<flatbuffers::String> datetime) {
    fbb_.AddOffset(ultVISION::VT_DATETIME, datetime);
  }
  void add_offset(const stfOFFSET *offset) {
    fbb_.AddStruct(ultVISION::VT_OFFSET, offset);
  }
  explicit ultVISIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ultVISIONBuilder &operator=(const ultVISIONBuilder &);
  flatbuffers::Offset<ultVISION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ultVISION>(end);
    return o;
  }
};

inline flatbuffers::Offset<ultVISION> CreateultVISION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> dieId = 0,
    flatbuffers::Offset<flatbuffers::String> result = 0,
    flatbuffers::Offset<flatbuffers::String> datetime = 0,
    const stfOFFSET *offset = 0) {
  ultVISIONBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_datetime(datetime);
  builder_.add_result(result);
  builder_.add_dieId(dieId);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ultVISION> CreateultVISIONDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *dieId = nullptr,
    const char *result = nullptr,
    const char *datetime = nullptr,
    const stfOFFSET *offset = 0) {
  return MitULT::CreateultVISION(
      _fbb,
      type ? _fbb.CreateString(type) : 0,
      dieId ? _fbb.CreateString(dieId) : 0,
      result ? _fbb.CreateString(result) : 0,
      datetime ? _fbb.CreateString(datetime) : 0,
      offset);
}

struct ultLOT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MACHINE = 4,
    VT_LOTNUM = 6,
    VT_PACKAGENAME = 8,
    VT_RECIPENAME = 10,
    VT_SHIFT = 12,
    VT_OPERATOR_ = 14
  };
  const flatbuffers::String *machine() const {
    return GetPointer<const flatbuffers::String *>(VT_MACHINE);
  }
  const flatbuffers::String *lotNum() const {
    return GetPointer<const flatbuffers::String *>(VT_LOTNUM);
  }
  const flatbuffers::String *packageName() const {
    return GetPointer<const flatbuffers::String *>(VT_PACKAGENAME);
  }
  const flatbuffers::String *recipeName() const {
    return GetPointer<const flatbuffers::String *>(VT_RECIPENAME);
  }
  const flatbuffers::String *shift() const {
    return GetPointer<const flatbuffers::String *>(VT_SHIFT);
  }
  const flatbuffers::String *operator_() const {
    return GetPointer<const flatbuffers::String *>(VT_OPERATOR_);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MACHINE) &&
           verifier.VerifyString(machine()) &&
           VerifyOffset(verifier, VT_LOTNUM) &&
           verifier.VerifyString(lotNum()) &&
           VerifyOffset(verifier, VT_PACKAGENAME) &&
           verifier.VerifyString(packageName()) &&
           VerifyOffset(verifier, VT_RECIPENAME) &&
           verifier.VerifyString(recipeName()) &&
           VerifyOffset(verifier, VT_SHIFT) &&
           verifier.VerifyString(shift()) &&
           VerifyOffset(verifier, VT_OPERATOR_) &&
           verifier.VerifyString(operator_()) &&
           verifier.EndTable();
  }
};

struct ultLOTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_machine(flatbuffers::Offset<flatbuffers::String> machine) {
    fbb_.AddOffset(ultLOT::VT_MACHINE, machine);
  }
  void add_lotNum(flatbuffers::Offset<flatbuffers::String> lotNum) {
    fbb_.AddOffset(ultLOT::VT_LOTNUM, lotNum);
  }
  void add_packageName(flatbuffers::Offset<flatbuffers::String> packageName) {
    fbb_.AddOffset(ultLOT::VT_PACKAGENAME, packageName);
  }
  void add_recipeName(flatbuffers::Offset<flatbuffers::String> recipeName) {
    fbb_.AddOffset(ultLOT::VT_RECIPENAME, recipeName);
  }
  void add_shift(flatbuffers::Offset<flatbuffers::String> shift) {
    fbb_.AddOffset(ultLOT::VT_SHIFT, shift);
  }
  void add_operator_(flatbuffers::Offset<flatbuffers::String> operator_) {
    fbb_.AddOffset(ultLOT::VT_OPERATOR_, operator_);
  }
  explicit ultLOTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ultLOTBuilder &operator=(const ultLOTBuilder &);
  flatbuffers::Offset<ultLOT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ultLOT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ultLOT> CreateultLOT(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> machine = 0,
    flatbuffers::Offset<flatbuffers::String> lotNum = 0,
    flatbuffers::Offset<flatbuffers::String> packageName = 0,
    flatbuffers::Offset<flatbuffers::String> recipeName = 0,
    flatbuffers::Offset<flatbuffers::String> shift = 0,
    flatbuffers::Offset<flatbuffers::String> operator_ = 0) {
  ultLOTBuilder builder_(_fbb);
  builder_.add_operator_(operator_);
  builder_.add_shift(shift);
  builder_.add_recipeName(recipeName);
  builder_.add_packageName(packageName);
  builder_.add_lotNum(lotNum);
  builder_.add_machine(machine);
  return builder_.Finish();
}

inline flatbuffers::Offset<ultLOT> CreateultLOTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *machine = nullptr,
    const char *lotNum = nullptr,
    const char *packageName = nullptr,
    const char *recipeName = nullptr,
    const char *shift = nullptr,
    const char *operator_ = nullptr) {
  return MitULT::CreateultLOT(
      _fbb,
      machine ? _fbb.CreateString(machine) : 0,
      lotNum ? _fbb.CreateString(lotNum) : 0,
      packageName ? _fbb.CreateString(packageName) : 0,
      recipeName ? _fbb.CreateString(recipeName) : 0,
      shift ? _fbb.CreateString(shift) : 0,
      operator_ ? _fbb.CreateString(operator_) : 0);
}

struct ultWAFER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DIESIZE = 4,
    VT_NOTCH = 6,
    VT_TARGETDIE = 8,
    VT_INPUTWAFERID = 10,
    VT_INPUTWAFERSIZE = 12,
    VT_INPUTMAXROWCOL = 14,
    VT_INPUTDIEGAP = 16,
    VT_OUTPUTWAFERID = 18,
    VT_OUTPUTWAFERSIZE = 20,
    VT_OUTPUTMAXROWCOL = 22,
    VT_OUTPUTDIEGAP = 24
  };
  const stfXY *dieSize() const {
    return GetStruct<const stfXY *>(VT_DIESIZE);
  }
  int16_t notch() const {
    return GetField<int16_t>(VT_NOTCH, 0);
  }
  const flatbuffers::Vector<const stXY *> *targetDie() const {
    return GetPointer<const flatbuffers::Vector<const stXY *> *>(VT_TARGETDIE);
  }
  const flatbuffers::String *inputwaferId() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUTWAFERID);
  }
  float inputwafersize() const {
    return GetField<float>(VT_INPUTWAFERSIZE, 200.0f);
  }
  const stXY *inputmaxRowCol() const {
    return GetStruct<const stXY *>(VT_INPUTMAXROWCOL);
  }
  const stfXY *inputdieGap() const {
    return GetStruct<const stfXY *>(VT_INPUTDIEGAP);
  }
  const flatbuffers::String *outputwaferId() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUTWAFERID);
  }
  float outputwafersize() const {
    return GetField<float>(VT_OUTPUTWAFERSIZE, 200.0f);
  }
  const stXY *outputmaxRowCol() const {
    return GetStruct<const stXY *>(VT_OUTPUTMAXROWCOL);
  }
  const stfXY *outputdieGap() const {
    return GetStruct<const stfXY *>(VT_OUTPUTDIEGAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<stfXY>(verifier, VT_DIESIZE) &&
           VerifyField<int16_t>(verifier, VT_NOTCH) &&
           VerifyOffset(verifier, VT_TARGETDIE) &&
           verifier.VerifyVector(targetDie()) &&
           VerifyOffset(verifier, VT_INPUTWAFERID) &&
           verifier.VerifyString(inputwaferId()) &&
           VerifyField<float>(verifier, VT_INPUTWAFERSIZE) &&
           VerifyField<stXY>(verifier, VT_INPUTMAXROWCOL) &&
           VerifyField<stfXY>(verifier, VT_INPUTDIEGAP) &&
           VerifyOffset(verifier, VT_OUTPUTWAFERID) &&
           verifier.VerifyString(outputwaferId()) &&
           VerifyField<float>(verifier, VT_OUTPUTWAFERSIZE) &&
           VerifyField<stXY>(verifier, VT_OUTPUTMAXROWCOL) &&
           VerifyField<stfXY>(verifier, VT_OUTPUTDIEGAP) &&
           verifier.EndTable();
  }
};

struct ultWAFERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dieSize(const stfXY *dieSize) {
    fbb_.AddStruct(ultWAFER::VT_DIESIZE, dieSize);
  }
  void add_notch(int16_t notch) {
    fbb_.AddElement<int16_t>(ultWAFER::VT_NOTCH, notch, 0);
  }
  void add_targetDie(flatbuffers::Offset<flatbuffers::Vector<const stXY *>> targetDie) {
    fbb_.AddOffset(ultWAFER::VT_TARGETDIE, targetDie);
  }
  void add_inputwaferId(flatbuffers::Offset<flatbuffers::String> inputwaferId) {
    fbb_.AddOffset(ultWAFER::VT_INPUTWAFERID, inputwaferId);
  }
  void add_inputwafersize(float inputwafersize) {
    fbb_.AddElement<float>(ultWAFER::VT_INPUTWAFERSIZE, inputwafersize, 200.0f);
  }
  void add_inputmaxRowCol(const stXY *inputmaxRowCol) {
    fbb_.AddStruct(ultWAFER::VT_INPUTMAXROWCOL, inputmaxRowCol);
  }
  void add_inputdieGap(const stfXY *inputdieGap) {
    fbb_.AddStruct(ultWAFER::VT_INPUTDIEGAP, inputdieGap);
  }
  void add_outputwaferId(flatbuffers::Offset<flatbuffers::String> outputwaferId) {
    fbb_.AddOffset(ultWAFER::VT_OUTPUTWAFERID, outputwaferId);
  }
  void add_outputwafersize(float outputwafersize) {
    fbb_.AddElement<float>(ultWAFER::VT_OUTPUTWAFERSIZE, outputwafersize, 200.0f);
  }
  void add_outputmaxRowCol(const stXY *outputmaxRowCol) {
    fbb_.AddStruct(ultWAFER::VT_OUTPUTMAXROWCOL, outputmaxRowCol);
  }
  void add_outputdieGap(const stfXY *outputdieGap) {
    fbb_.AddStruct(ultWAFER::VT_OUTPUTDIEGAP, outputdieGap);
  }
  explicit ultWAFERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ultWAFERBuilder &operator=(const ultWAFERBuilder &);
  flatbuffers::Offset<ultWAFER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ultWAFER>(end);
    return o;
  }
};

inline flatbuffers::Offset<ultWAFER> CreateultWAFER(
    flatbuffers::FlatBufferBuilder &_fbb,
    const stfXY *dieSize = 0,
    int16_t notch = 0,
    flatbuffers::Offset<flatbuffers::Vector<const stXY *>> targetDie = 0,
    flatbuffers::Offset<flatbuffers::String> inputwaferId = 0,
    float inputwafersize = 200.0f,
    const stXY *inputmaxRowCol = 0,
    const stfXY *inputdieGap = 0,
    flatbuffers::Offset<flatbuffers::String> outputwaferId = 0,
    float outputwafersize = 200.0f,
    const stXY *outputmaxRowCol = 0,
    const stfXY *outputdieGap = 0) {
  ultWAFERBuilder builder_(_fbb);
  builder_.add_outputdieGap(outputdieGap);
  builder_.add_outputmaxRowCol(outputmaxRowCol);
  builder_.add_outputwafersize(outputwafersize);
  builder_.add_outputwaferId(outputwaferId);
  builder_.add_inputdieGap(inputdieGap);
  builder_.add_inputmaxRowCol(inputmaxRowCol);
  builder_.add_inputwafersize(inputwafersize);
  builder_.add_inputwaferId(inputwaferId);
  builder_.add_targetDie(targetDie);
  builder_.add_dieSize(dieSize);
  builder_.add_notch(notch);
  return builder_.Finish();
}

inline flatbuffers::Offset<ultWAFER> CreateultWAFERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const stfXY *dieSize = 0,
    int16_t notch = 0,
    const std::vector<stXY> *targetDie = nullptr,
    const char *inputwaferId = nullptr,
    float inputwafersize = 200.0f,
    const stXY *inputmaxRowCol = 0,
    const stfXY *inputdieGap = 0,
    const char *outputwaferId = nullptr,
    float outputwafersize = 200.0f,
    const stXY *outputmaxRowCol = 0,
    const stfXY *outputdieGap = 0) {
  return MitULT::CreateultWAFER(
      _fbb,
      dieSize,
      notch,
      targetDie ? _fbb.CreateVectorOfStructs<stXY>(*targetDie) : 0,
      inputwaferId ? _fbb.CreateString(inputwaferId) : 0,
      inputwafersize,
      inputmaxRowCol,
      inputdieGap,
      outputwaferId ? _fbb.CreateString(outputwaferId) : 0,
      outputwafersize,
      outputmaxRowCol,
      outputdieGap);
}

struct ultUNIT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GOODDIE = 4,
    VT_PLACEDDIE = 6,
    VT_INPUTCOOR = 8,
    VT_OUTPUTCOOR = 10,
    VT_PNP = 12,
    VT_PICKFORCE = 14,
    VT_PLACEFORCE = 16,
    VT_PURGEFORCE = 18,
    VT_BINCODE = 20,
    VT_REJCODE = 22
  };
  int64_t goodDie() const {
    return GetField<int64_t>(VT_GOODDIE, 0);
  }
  int64_t placedDie() const {
    return GetField<int64_t>(VT_PLACEDDIE, 0);
  }
  const stXY *inputCoor() const {
    return GetStruct<const stXY *>(VT_INPUTCOOR);
  }
  const stXY *outputCoor() const {
    return GetStruct<const stXY *>(VT_OUTPUTCOOR);
  }
  int16_t pnp() const {
    return GetField<int16_t>(VT_PNP, 0);
  }
  int16_t pickForce() const {
    return GetField<int16_t>(VT_PICKFORCE, 0);
  }
  int16_t placeForce() const {
    return GetField<int16_t>(VT_PLACEFORCE, 0);
  }
  int16_t purgeForce() const {
    return GetField<int16_t>(VT_PURGEFORCE, 0);
  }
  int16_t bincode() const {
    return GetField<int16_t>(VT_BINCODE, 0);
  }
  int16_t rejcode() const {
    return GetField<int16_t>(VT_REJCODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_GOODDIE) &&
           VerifyField<int64_t>(verifier, VT_PLACEDDIE) &&
           VerifyField<stXY>(verifier, VT_INPUTCOOR) &&
           VerifyField<stXY>(verifier, VT_OUTPUTCOOR) &&
           VerifyField<int16_t>(verifier, VT_PNP) &&
           VerifyField<int16_t>(verifier, VT_PICKFORCE) &&
           VerifyField<int16_t>(verifier, VT_PLACEFORCE) &&
           VerifyField<int16_t>(verifier, VT_PURGEFORCE) &&
           VerifyField<int16_t>(verifier, VT_BINCODE) &&
           VerifyField<int16_t>(verifier, VT_REJCODE) &&
           verifier.EndTable();
  }
};

struct ultUNITBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_goodDie(int64_t goodDie) {
    fbb_.AddElement<int64_t>(ultUNIT::VT_GOODDIE, goodDie, 0);
  }
  void add_placedDie(int64_t placedDie) {
    fbb_.AddElement<int64_t>(ultUNIT::VT_PLACEDDIE, placedDie, 0);
  }
  void add_inputCoor(const stXY *inputCoor) {
    fbb_.AddStruct(ultUNIT::VT_INPUTCOOR, inputCoor);
  }
  void add_outputCoor(const stXY *outputCoor) {
    fbb_.AddStruct(ultUNIT::VT_OUTPUTCOOR, outputCoor);
  }
  void add_pnp(int16_t pnp) {
    fbb_.AddElement<int16_t>(ultUNIT::VT_PNP, pnp, 0);
  }
  void add_pickForce(int16_t pickForce) {
    fbb_.AddElement<int16_t>(ultUNIT::VT_PICKFORCE, pickForce, 0);
  }
  void add_placeForce(int16_t placeForce) {
    fbb_.AddElement<int16_t>(ultUNIT::VT_PLACEFORCE, placeForce, 0);
  }
  void add_purgeForce(int16_t purgeForce) {
    fbb_.AddElement<int16_t>(ultUNIT::VT_PURGEFORCE, purgeForce, 0);
  }
  void add_bincode(int16_t bincode) {
    fbb_.AddElement<int16_t>(ultUNIT::VT_BINCODE, bincode, 0);
  }
  void add_rejcode(int16_t rejcode) {
    fbb_.AddElement<int16_t>(ultUNIT::VT_REJCODE, rejcode, 0);
  }
  explicit ultUNITBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ultUNITBuilder &operator=(const ultUNITBuilder &);
  flatbuffers::Offset<ultUNIT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ultUNIT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ultUNIT> CreateultUNIT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t goodDie = 0,
    int64_t placedDie = 0,
    const stXY *inputCoor = 0,
    const stXY *outputCoor = 0,
    int16_t pnp = 0,
    int16_t pickForce = 0,
    int16_t placeForce = 0,
    int16_t purgeForce = 0,
    int16_t bincode = 0,
    int16_t rejcode = 0) {
  ultUNITBuilder builder_(_fbb);
  builder_.add_placedDie(placedDie);
  builder_.add_goodDie(goodDie);
  builder_.add_outputCoor(outputCoor);
  builder_.add_inputCoor(inputCoor);
  builder_.add_rejcode(rejcode);
  builder_.add_bincode(bincode);
  builder_.add_purgeForce(purgeForce);
  builder_.add_placeForce(placeForce);
  builder_.add_pickForce(pickForce);
  builder_.add_pnp(pnp);
  return builder_.Finish();
}

struct ultOBJECT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOTINFO = 4,
    VT_WAFERINFO = 6,
    VT_MAP = 8,
    VT_ULT = 10
  };
  const ultLOT *lotInfo() const {
    return GetPointer<const ultLOT *>(VT_LOTINFO);
  }
  const ultWAFER *waferInfo() const {
    return GetPointer<const ultWAFER *>(VT_WAFERINFO);
  }
  const flatbuffers::Vector<int16_t> *map() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_MAP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ultUNIT>> *ult() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ultUNIT>> *>(VT_ULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOTINFO) &&
           verifier.VerifyTable(lotInfo()) &&
           VerifyOffset(verifier, VT_WAFERINFO) &&
           verifier.VerifyTable(waferInfo()) &&
           VerifyOffset(verifier, VT_MAP) &&
           verifier.VerifyVector(map()) &&
           VerifyOffset(verifier, VT_ULT) &&
           verifier.VerifyVector(ult()) &&
           verifier.VerifyVectorOfTables(ult()) &&
           verifier.EndTable();
  }
};

struct ultOBJECTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lotInfo(flatbuffers::Offset<ultLOT> lotInfo) {
    fbb_.AddOffset(ultOBJECT::VT_LOTINFO, lotInfo);
  }
  void add_waferInfo(flatbuffers::Offset<ultWAFER> waferInfo) {
    fbb_.AddOffset(ultOBJECT::VT_WAFERINFO, waferInfo);
  }
  void add_map(flatbuffers::Offset<flatbuffers::Vector<int16_t>> map) {
    fbb_.AddOffset(ultOBJECT::VT_MAP, map);
  }
  void add_ult(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ultUNIT>>> ult) {
    fbb_.AddOffset(ultOBJECT::VT_ULT, ult);
  }
  explicit ultOBJECTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ultOBJECTBuilder &operator=(const ultOBJECTBuilder &);
  flatbuffers::Offset<ultOBJECT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ultOBJECT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ultOBJECT> CreateultOBJECT(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ultLOT> lotInfo = 0,
    flatbuffers::Offset<ultWAFER> waferInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> map = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ultUNIT>>> ult = 0) {
  ultOBJECTBuilder builder_(_fbb);
  builder_.add_ult(ult);
  builder_.add_map(map);
  builder_.add_waferInfo(waferInfo);
  builder_.add_lotInfo(lotInfo);
  return builder_.Finish();
}

inline flatbuffers::Offset<ultOBJECT> CreateultOBJECTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ultLOT> lotInfo = 0,
    flatbuffers::Offset<ultWAFER> waferInfo = 0,
    const std::vector<int16_t> *map = nullptr,
    const std::vector<flatbuffers::Offset<ultUNIT>> *ult = nullptr) {
  return MitULT::CreateultOBJECT(
      _fbb,
      lotInfo,
      waferInfo,
      map ? _fbb.CreateVector<int16_t>(*map) : 0,
      ult ? _fbb.CreateVector<flatbuffers::Offset<ultUNIT>>(*ult) : 0);
}

inline const MitULT::ultOBJECT *GetultOBJECT(const void *buf) {
  return flatbuffers::GetRoot<MitULT::ultOBJECT>(buf);
}

inline const MitULT::ultOBJECT *GetSizePrefixedultOBJECT(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<MitULT::ultOBJECT>(buf);
}

inline bool VerifyultOBJECTBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MitULT::ultOBJECT>(nullptr);
}

inline bool VerifySizePrefixedultOBJECTBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MitULT::ultOBJECT>(nullptr);
}

inline void FinishultOBJECTBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MitULT::ultOBJECT> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedultOBJECTBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MitULT::ultOBJECT> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace MitULT

#endif  // FLATBUFFERS_GENERATED_MITULT_MITULT_H_
